project('renderer')
# Functions
# function(['nova_set_all_target_outputs', 'target', 'output_dir'])
# set_target_properties([target, 'PROPERTIES', 'LIBRARY_OUTPUT_DIRECTORY', output_dir])
# set_target_properties([target, 'PROPERTIES', 'LIBRARY_OUTPUT_DIRECTORY_DEBUG', output_dir])
# set_target_properties([target, 'PROPERTIES', 'LIBRARY_OUTPUT_DIRECTORY_RELEASE', output_dir])
# set_target_properties([target, 'PROPERTIES', 'ARCHIVE_OUTPUT_DIRECTORY', output_dir])
# set_target_properties([target, 'PROPERTIES', 'ARCHIVE_OUTPUT_DIRECTORY_DEBUG', output_dir])
# set_target_properties([target, 'PROPERTIES', 'ARCHIVE_OUTPUT_DIRECTORY_RELEASE', output_dir])
# set_target_properties([target, 'PROPERTIES', 'RUNTIME_OUTPUT_DIRECTORY', output_dir])
# set_target_properties([target, 'PROPERTIES', 'RUNTIME_OUTPUT_DIRECTORY_DEBUG', output_dir])
# set_target_properties([target, 'PROPERTIES', 'RUNTIME_OUTPUT_DIRECTORY_RELEASE', output_dir])
# endfunction()
# Initialize cmake options
cmake_module_path = '${CMAKE_CURRENT_LIST_DIR}/cmake'
cmake_cxx_standard = '17'
cmake_c_standard = '11'
cmake_cxx_flags = '${CMAKE_CXX_FLAGS} -DCMAKE_BUILD_TYPE=RELEASE'
cmake_runtime_output_directory = cmake_binary_dir
cmake_library_output_directory = cmake_binary_dir
cmake_install_prefix = cmake_current_list_dir
# Setup 3rd party dependencies.
3rd_party_dir = [cmake_current_list_dir, '/3rdparty']
Vulkan_dep = dependency('Vulkan')
glfw_build_docs = ['OFF', 'CACHE', 'BOOL', '', 'FORCE']
glfw_build_tests = ['OFF', 'CACHE', 'BOOL', '', 'FORCE']
glfw_build_examples = ['OFF', 'CACHE', 'BOOL', '', 'FORCE']
JNI_dep = dependency('JNI')
# need to compile GLFW and JSON
#add_subdirectory(${3RD_PARTY_DIR}/glfw)
#add_subdirectory(${3RD_PARTY_DIR}/json)
#add_subdirectory(${3RD_PARTY_DIR}/glm)
#add_subdirectory(${3RD_PARTY_DIR}/easyloggingpp)
#add_subdirectory(${3RD_PARTY_DIR}/miniz)
#add_subdirectory(${3RD_PARTY_DIR}/googletest)
#add_subdirectory(${3RD_PARTY_DIR}/optional)
#add_subdirectory(${3RD_PARTY_DIR}/spirv-headers)
#add_subdirectory(${3RD_PARTY_DIR}/spirv-tools)
#add_subdirectory(${3RD_PARTY_DIR}/glslang)
#add_subdirectory(${3RD_PARTY_DIR}/shaderc)
#add_subdirectory(${3RD_PARTY_DIR}/vpp)
#add_subdirectory(${3RD_PARTY_DIR}/ny)
#add_subdirectory(${3RD_PARTY_DIR}/nytl)
# include_directories(['SYSTEM', vulkan_include_dirs, jni_include_dirs, 3rd_party_dir, '/glfw/include', 3rd_party_dir, '/easyloggingpp/src', 3rd_party_dir, '/glad/include', 3rd_party_dir, '/glm', 3rd_party_dir, '/miniz', 3rd_party_dir, '/json/src', 3rd_party_dir, '/googletest/googletest/include', 3rd_party_dir, '/optional', 3rd_party_dir, '/renderdocapi', 3rd_party_dir, '/VulkanMemoryAllocator/src', 3rd_party_dir, '/shaderc/libshaderc/include', 3rd_party_dir, '/minitrace', 3rd_party_dir, '/vpp/include', 3rd_party_dir, '/ny/include', 3rd_party_dir, '/nytl/include'])
common_link_libs = [cmake_dl_libs, 'glfw', glfw_libraries, vulkan_libraries, jni_libraries, 'shaderc', 'stdc++fs']
# Setup the nova-core library.
nova_headers = ['render/objects/uniform_buffers/uniform_buffer_definitions.h', 'mc_interface/nova.h', 'render/nova_renderer.h', 'render/objects/textures/texture_manager.h', 'utils/types.h', 'render/objects/shaders/vk_shader_program.h', 'render/objects/uniform_buffers/gl_uniform_buffer.h', 'render/objects/meshes/vk_mesh.h', 'render/objects/textures/texture2D.h', 'render/windowing/glfw_vk_window.h', 'input/InputHandler.h', 'mc_interface/mc_gui_objects.h', 'mc_interface/mc_objects.h', 'utils/utils.h', 'data_loading/settings.h', 'data_loading/loaders/loaders.h', 'data_loading/loaders/shader_loading.h', 'data_loading/loaders/loader_utils.h', 'render/objects/meshes/mesh_store.h', 'render/objects/render_object.h', 'render/objects/uniform_buffers/uniform_buffer_store.h', 'render/objects/uniform_buffers/uniform_buffer_definitions.h', 'render/objects/uniform_buffers/gl_uniform_buffer.h', 'physics/aabb.h', 'data_loading/loaders/shader_source_structs.h', 'render/objects/meshes/mesh_definition.h', 'render/objects/camera.h', 'render/objects/renderpass.h', 'utils/io.h', 'render/objects/shaders/shader_resource_manager.h', 'data_loading/direct_buffers.h', 'mc_interface/nova_jni.h', 'render/objects/render_object.h', 'utils/stb_image_write.h', 'render/objects/renderpasses/renderpass_manager.h', 'render/vulkan/render_context.h', 'render/vulkan/command_pool.h']
nova_source = ['3rdparty/miniz/miniz.c', '3rdparty/miniz/miniz_tdef.c', '3rdparty/miniz/miniz_tinfl.c', '3rdparty/miniz/miniz_zip.c', '3rdparty/easyloggingpp/src/easylogging++.cc', '3rdparty/minitrace/minitrace.c', 'render/nova_renderer.cpp', 'mc_interface/nova_facade.cpp', 'render/objects/textures/texture_manager.cpp', 'render/objects/uniform_buffers/uniform_buffer_store.cpp', 'input/InputHandler.cpp', 'render/objects/shaders/vk_shader_program.cpp', 'render/objects/meshes/vk_mesh.cpp', 'render/objects/textures/texture2D.cpp', 'render/windowing/glfw_vk_window.cpp', 'utils/utils.cpp', 'data_loading/settings.cpp', 'data_loading/loaders/shader_loading.cpp', 'data_loading/loaders/loader_utils.cpp', 'render/objects/shaders/shaderpack.cpp', 'render/objects/meshes/mesh_store.cpp', 'physics/aabb.cpp', 'render/objects/meshes/mesh_definition.cpp', 'render/objects/uniform_buffers/uniform_buffers_definitions.cpp', 'mc_interface/mc_objects.cpp', 'render/objects/camera.cpp', 'data_loading/loaders/shader_source_structs.cpp', 'data_loading/direct_buffers.cpp', 'render/objects/render_object.cpp', 'render/vulkan/command_pool.cpp', 'render/objects/renderpasses/renderpass_manager.cpp', 'render/objects/renderpasses/materials.h', 'render/objects/renderpasses/materials.cpp', 'render/vulkan/render_context.cpp', 'render/objects/shaders/shader_resource_manager.cpp']
if 'WIN32'
  nova_source = [nova_source, nova_headers, '3rdparty/renderdocapi/RenderDocManager.cpp']
endif
if 'UNIX'
  cmake_cxx_flags = '${CMAKE_CXX_FLAGS} -DELPP_STACKTRACE_ON_CRASH -g'
endif
if 'MSVC'
  # Force to always compile with W4
  if 'CMAKE_CXX_FLAGS', 'MATCHES', '/W[0-4]'
    # string(['REGEX', 'REPLACE', '/W[0-4]', '/W4', 'CMAKE_CXX_FLAGS', '${CMAKE_CXX_FLAGS}'])
  else
    cmake_cxx_flags = '${CMAKE_CXX_FLAGS} /W4'
  endif
elif 'CMAKE_COMPILER_IS_GNUCC', 'OR', 'CMAKE_COMPILER_IS_GNUCXX'
  # Update if necessary
  cmake_cxx_flags = '${CMAKE_CXX_FLAGS} -Wall -Wno-long-long -pedantic'
endif
# For now just put everthing in a single nova source group
# because there are several sub groups that would be extremely small
# source_group(['nova', 'FILES', nova_headers, nova_no_compile, nova_source])
nova-renderer-obj_lib = static_library('nova-renderer-obj', 'OBJECT', nova_source, glad_source, miniz_source)
# set_target_properties(['nova-renderer-obj', 'PROPERTIES', 'POSITION_INDEPENDENT_CODE', 'TRUE'])
# target_compile_definitions(['nova-renderer-obj', 'PRIVATE', 'DLL_EXPORT', 'ELPP_THREAD_SAFE'])
# target_compile_definitions(['nova-renderer-obj', 'PUBLIC', 'DLL_EXPORT', 'ELPP_THREAD_SAFE'])
nova-renderer_lib = shared_library('nova-renderer', '$<TARGET_OBJECTS:nova-renderer-obj>')
if 'WIN32'
  # set_target_properties(['nova-renderer', 'PROPERTIES', 'PREFIX', ''])
endif
# This is needed on MSVC otherwise the build files get spread out all over the place.
# The only *problem* is that we wont be able to create multi-config builds. Personally
# I dont see this as a problem currently. This will make the location more predictable
# cross platform as well. Though i think object files are still cached across build
# types so this should be fine.
# get_target_property(['OUTPUT_DIR', 'nova-renderer', 'LIBRARY_OUTPUT_DIRECTORY'])
# nova_set_all_target_outputs(['nova-renderer', output_dir])
if 'CMAKE_SYSTEM_NAME', 'MATCHES', 'Linux'
  # set_target_properties(['nova-renderer', 'PROPERTIES', 'CXX_VISIBILITY_PRESET', 'hidden'])
endif
nova-test_exe = executable('nova-test', 'test/main.cpp', nova_source)
# target_link_libraries(['nova-test', common_link_libs])
# target_compile_definitions(['nova-test', 'PUBLIC', 'STATIC_LINKAGE'])
# set_target_properties(['nova-test', 'PROPERTIES', 'RUNTIME_OUTPUT_DIRECTORY', '${CMAKE_BINARY_DIR}'])
# Not sure if this is actually doing anything
if 'GLFW_COMPILED'
  # add_dependencies(['nova-renderer', 'glfw3'])
endif
# target_link_libraries(['nova-renderer', common_link_libs])
if 'WIN32'
  # add_custom_command(['TARGET', 'nova-renderer', 'POST_BUILD', 'COMMAND', 'copy', '/Y', 'nova-renderer.dll', '..\\..\\..\\jars\\versions\\1.10\\1.10-natives'])
endif
if 'UNIX'
  # add_custom_command(['TARGET', 'nova-renderer', 'POST_BUILD', 'COMMAND', 'cp', '-f', '${CMAKE_CURRENT_LIST_DIR}/libnova-renderer.so', '${CMAKE_CURRENT_LIST_DIR}/../../../jars/versions/1.10/1.10-natives'])
endif
